import numpy as np
import random

def perform_rsa(boundaries, num_dim, number_pts, min_dist_func = None,
                dist_func = np.linalg.norm):
  """
  Function: perform random sequential addition (RSA) to generate n RSA points

  Input:
    - boundaries (list of tuples): each tuple in array has the form
      (i_low_lim, i_high_lim) where i_low_lim and i_high_lim represents the
      lower and upper boundary of the ith dimension, respectively

    - num_dim (int): an explicit parameter ensuring that the number of
      dimensions in boundaries is as intended (will throw error otherwise)
    - number_pts (integer): number of points to generate
    - min_dist_func (func): minimum distance between randomly generated points
      (could be a constant or pointer to function)
    - dist_func (pointer to function): distance function/metric to use to find
      distance between points

  Output:
    - all_rsa_pts (float array with dim (number_pts x num_dim)):
      each list is a point generated by RSA
  """

  # check user knows what dimensions they're inputting
  if len(boundaries) != num_dim:
      raise Exception("num dim doesnt agree")

  # for our purposes, we only deal with 2D or 3D
  if num_dim == 2:
    min_dist_func = min_dist_2D
    # if min_dist_func != min_dist_2D:
    #   print("Are you sure you don't mean to use min_dist_2D since num_dim=2?")
  elif num_dim == 3:
    min_dist_func = min_dist_3D

  # generate an array to contain all the points at once
  # first column is x coordinate of ith point/row
  # second column is y coordinate of ith point/row
  # third column ...
  all_rsa_pts = np.empty(shape=(number_pts,num_dim))
  center = np.empty(shape=(num_dim))
  # for the first point/row, assign valid random values based on boundaries
  for i in range(0, num_dim):
    all_rsa_pts[0,i] = random.uniform(boundaries[i][0],boundaries[i][1])
    center[i] = (boundaries[i][0] + boundaries[i][1]) / 2

  # the last valid point created is the first one, initialized above.
  # while the next point created is not valid, continue to recreate it, once
  # it is valid, then update index_last_valid_pt by 1 and repeat until
  # index_last_valid_pt = number_pts-1
  # which entails that the last row/element/point in the all_rsa_pts is valid
  # i.e. all points are now valid
  index_last_valid_pt = 0
  # generate the next random pt
  while index_last_valid_pt < number_pts-1:
    cur_pt_idx = index_last_valid_pt+1

    # select a slice from the initialized array (a numpy "view")
    cur_rand_pt = all_rsa_pts[cur_pt_idx,:]

    for i in range(0,num_dim):
      # generate the value for dimension i
      cur_rand_pt[i] = random.uniform(boundaries[i][0],boundaries[i][1])

    # ensure that point's distance to already-present points is acceptable,
    # range over all the valid points so far
    acceptable_dist = True
    for other_pt_idx in range(0,index_last_valid_pt+1):

      # never compare the point against itself, otherwise infinite loop
      if other_pt_idx == cur_pt_idx:
        continue

      # slice out the other point
      other_pt = all_rsa_pts[other_pt_idx,:]

      if dist_func(other_pt - cur_rand_pt) < min_dist_func(cur_rand_pt,center):
          # stop early, if one point is too close, then this cur_rand_pt is not
          # acceptable
          acceptable_dist = False
          break

    # add the point if its valid
    if acceptable_dist:
      # a valid point has been selected, advance to the next index
      index_last_valid_pt += 1

  return all_rsa_pts, center

def min_dist_2D(pt, center):
  return 0.146 * np.linalg.norm(pt - center) ** (1/3)

def min_dist_3D(pt, center):
  return 0.146 * np.linalg.norm(pt - center) ** (2/3)